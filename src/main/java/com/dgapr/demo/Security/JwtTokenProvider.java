package com.dgapr.demo.Security;

import com.dgapr.demo.Model.User.User;
import com.dgapr.demo.Repository.UserRepository;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Date;

/**
 * {@code JwtTokenProvider} is a utility class responsible for generating, validating,
 * and extracting information from JSON Web Tokens (JWTs) used for authentication
 * within the application. It ensures secure communication by signing tokens with a
 * secret key and implementing a token versioning mechanism for revocation.
 *
 * <p>Tokens generated by this provider include the user's username (as the subject)
 * and a custom claim, "v", which represents the user's token version. This version
 * is crucial for the token revocation strategy, allowing tokens to be invalidated
 * if a user's password changes or their tokens are explicitly revoked by an administrator.</p>
 *
 * @see JwtAuthenticationFilter
 * @see UserRepository
 */
@Component
@RequiredArgsConstructor
public class JwtTokenProvider {

    private static final Logger log = LoggerFactory.getLogger(JwtTokenProvider.class);

    /**
     * The name of the HTTP header used for authorization (e.g., "Authorization").
     */
    public static final String AUTH_HEADER = "Authorization";

    /**
     * The prefix for the token value in the Authorization header (e.g., "Bearer ").
     */
    private static final String TOKEN_PREFIX = "Bearer ";

    /**
     * The secret key string used for signing JWTs, loaded from application properties (e.g., `jwt.secret.v2`).
     * This key must be kept confidential and secure.
     */
    @Value("${jwt.secret.v2}")
    private String jwtSecret;

    /**
     * The expiration time for JWTs in milliseconds, loaded from application properties (e.g., `jwt.expirationMs`).
     * This determines how long a generated token remains valid.
     */
    @Value("${jwt.expirationMs}")
    private long jwtExpirationMs;

    /**
     * The {@link SecretKey} derived from {@link #jwtSecret}, used internally for cryptographic
     * operations (signing and verifying JWTs).
     */
    private SecretKey key;

    /**
     * Initializes the {@link SecretKey} used for signing and verifying JWTs.
     * This method is automatically invoked after the bean's construction by Spring.
     * It converts the {@link #jwtSecret} string into a secure HMAC SHA key.
     */
    @PostConstruct
    public void init() {
        key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Generates a new signed JWT for an authenticated user.
     * The token includes the user's username as the subject, issue date, expiration date,
     * and a custom "v" claim representing the user's current token version.
     *
     * @param auth The {@link Authentication} object representing the authenticated principal,
     * from which the username and token version are extracted.
     * @return A {@code String} representing the full token, prefixed with "Bearer ".
     */
    public String generateToken(Authentication auth) {

        String username = auth.getName();
        User userPrincipal = (User) auth.getPrincipal();
        long tokenVersion = userPrincipal.getTokenVersion();
        Instant now = Instant.now();
        Instant expiry = now.plusMillis(jwtExpirationMs);

        String token = Jwts.builder()
                .subject(username)
                .issuedAt(Date.from(now))
                .expiration(Date.from(expiry))
                .claim("v", tokenVersion)
                .signWith(key) // Sign the token with the secret key
                .compact();

        return TOKEN_PREFIX + token; // Return the token with the "Bearer" prefix
    }

    /**
     * Validates the signature and expiration of a given JWT.
     *
     * @param requestToken The JWT string to validate. This string should *not*
     * include the "Bearer " prefix.
     * @return {@code true} if the token is valid (signature matches and not expired);
     * {@code false} otherwise (e.g., expired, invalid signature, or malformed).
     * @see #parseClaims(String)
     */
    public boolean validateToken(String requestToken) {
        try {
            parseClaims(requestToken);
            return true;
        } catch (ExpiredJwtException e) {
            log.warn("JWT expired: {}", e.getMessage());
        } catch (JwtException | IllegalArgumentException e) {
            log.warn("JWT invalid: {}", e.getMessage());
        }
        return false;
    }

    /**
     * Parses the claims (payload) from a JWT. This method also implicitly performs
     * signature verification and checks for expiration.
     *
     * @param rawToken The JWT string, which may optionally include the "Bearer " prefix.
     * @return The {@link Claims} object containing the token's payload.
     * @throws JwtException If the token is invalid (e.g., bad signature, malformed, expired).
     */
    public Claims parseClaims(String rawToken) {

        String token = rawToken.startsWith(TOKEN_PREFIX)
                ? rawToken.substring(TOKEN_PREFIX.length())
                : rawToken;

        return Jwts.parser()
                .verifyWith(key) // Set the key for verification
                .build()
                .parseSignedClaims(token) // Parse the signed JWT to extract claims
                .getPayload(); // Return the claims payload
    }

    /**
     * Extracts the username (subject) from a given JWT.
     *
     * @param rawToken The JWT string, which may optionally include the "Bearer " prefix.
     * @return The username (subject) stored within the JWT.
     * @throws JwtException If the token is invalid or the subject claim is missing.
     * @see #parseClaims(String)
     */
    public String getUsernameFromJwt(String rawToken) {
        return parseClaims(rawToken).getSubject();
    }

    /**
     * Extracts the custom numeric "v" (token version) claim from a JWT.
     * This claim is used as part of the token revocation strategy.
     *
     * @param rawToken The JWT string, which may optionally include the "Bearer " prefix.
     * @return The long value of the "v" claim. Returns {@code -1L} if the claim is
     * missing or is not a valid number.
     * @throws JwtException If the token is invalid.
     * @see #parseClaims(String)
     */
    public long getTokenVersionFromJwt(String rawToken) {
        Object v = parseClaims(rawToken).get("v"); // Retrieve the "v" claim
        return (v instanceof Number) ? ((Number) v).longValue() : -1L;
    }
}